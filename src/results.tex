\section{Results \& evaluation}
As stated earlier, the filesystem was split into two parts: a filesystem logic part (the \textit{adafs} package), and an I/O part (the \textit{disk} package).
Because the logic part is easier to verify, it was the primary focus of formal verification for this project.
Subprograms were given functional and data contracts, and type definitions according to their expected functionality.
Although this does not formally verify the functionality of the entire filesystem, it is a good starting point.
\autoref{code:prover summary} shows a summary of the conducted checks, and \autoref{code:prover output} shows some of the locations of various checks.

\begin{lstlisting}[basicstyle=\tiny, caption={Prover summary (\textnormal{gnatprove})}, label={code:prover summary}]
Summary of SPARK analysis
=========================

---------------------------------------------------------------------------------------------------------
SPARK Analysis results        Total        Flow   Interval   CodePeer      Provers   Justified   Unproved
---------------------------------------------------------------------------------------------------------
Data Dependencies                 5           5          .          .            .           .          .
Flow Dependencies                 4           4          .          .            .           .          .
Initialization                    2           2          .          .            .           .          .
Non-Aliasing                      .           .          .          .            .           .          .
Run-time Checks                  19           .          .          .    19 (CVC4)           .          .
Assertions                        2           .          .          .     2 (CVC4)           .          .
Functional Contracts              6           .          .          .     6 (CVC4)           .          .
LSP Verification                  .           .          .          .            .           .          .
---------------------------------------------------------------------------------------------------------
Total                            38    11 (29%)          .          .     27 (71%)           .          .

max steps used for successful proof: 1

Analyzed 18 units
\end{lstlisting}

\begin{lstlisting}[basicstyle=\tiny, caption={Excerpt from the prover output (\textnormal{gnatprove})}, label={code:prover output}]
adafs-inode.adb:6:27: info: division check proved (CVC4: 1 VC in max 0.0 seconds and 1 step)
adafs-inode.adb:6:27: info: range check proved (CVC4: 1 VC in max 0.0 seconds and 1 step)
adafs-inode.adb:8:44: info: division check proved (CVC4: 1 VC in max 0.0 seconds and 1 step)
adafs-inode.adb:13:12: info: overflow check proved (CVC4: 1 VC in max 0.0 seconds and 1 step)
adafs-inode.adb:14:12: info: division check proved (CVC4: 1 VC in max 0.0 seconds and 1 step)
adafs-inode.adb:14:12: info: range check proved (CVC4: 1 VC in max 0.0 seconds and 1 step)
adafs-inode.adb:14:28: info: overflow check proved (CVC4: 1 VC in max 0.0 seconds and 1 step)
adafs-inode.ads:40:60: info: range check proved (CVC4: 1 VC in max 0.0 seconds and 1 step)
adafs-inode.ads:66:10: info: data dependencies proved
adafs-inode.ads:67:10: info: flow dependencies proved
adafs-inode.ads:69:18: info: postcondition proved (CVC4: 2 VC in max 0.0 seconds and 1 step)
adafs-proc.adb:6:14: info: discriminant check proved (CVC4: 2 VC in max 0.0 seconds and 1 step)
adafs-proc.adb:12:16: info: discriminant check proved (CVC4: 2 VC in max 0.0 seconds and 1 step)
adafs-proc.ads:26:05: info: data dependencies proved
adafs-filp.adb:18:30: info: loop invariant initialization proved (CVC4: 1 VC in max 0.0 seconds and 1 step)
adafs-filp.adb:18:30: info: loop invariant preservation proved (CVC4: 1 VC in max 0.0 seconds and 1 step)
adafs-filp.ads:28:13: info: postcondition proved (CVC4: 3 VC in max 0.0 seconds and 1 step)
adafs-filp.ads:32:28: info: initialization of "free_fd" proved
adafs-filp.ads:33:05: info: data dependencies proved
adafs-filp.ads:34:05: info: flow dependencies proved
adafs-filp.ads:35:13: info: postcondition proved (CVC4: 2 VC in max 0.0 seconds and 1 step)
\end{lstlisting}

The checks done by the prover can each be related directly to a Common Weakness Enumeration (CWE) number; these are shown in \autoref{tab:checks and cwe numbers} \cite{sparkUG}.

\begin{table}[h]
  \centering
  \vspace{1em}
  \renewcommand{\arraystretch}{1.5}
  \begin{tabular}{| l | l |}
    \hline
    \textbf{Message} & \textbf{CWE number} \\ \hline
    divide by zero & 369 \\ \hline
    index check & 120 \\ \hline
    overflow check & 190 \\ \hline
    fp\_overflow check & 739 \\ \hline
    range check & 682 \\ \hline
    predicate check & 682 \\ \hline
    predicate check on default value & 682 \\ \hline
    null pointer dereference & 476 \\ \hline
    memory leak & 401 \\ \hline
    memory leak at end of scope & 401 \\ \hline
    discriminant check & 136 \\ \hline
    tag check & 136 \\ \hline
    use of an uninitialized variable & 457 \\ \hline
    precondition & 628 \\ \hline
    postcondition & 682 \\ \hline
  \end{tabular}
  \renewcommand{\arraystretch}{1}
  \vspace{1em}
  \caption{SPARK checks with their respective CWE numbers}
  \label{tab:checks and cwe numbers}
\end{table}

Due to Ada's type system, many of the checks do not take much effort to verify; in fact, all of the conducted checks were verified in one step.
The assurances provided by the prover are powerful, as they mean that e.g. overflow errors and range errors can \textit{never} happen at those locations.
In standard Ada, instructions are emitted to check that e.g. array accesses are within the bounds of the array.
However, with SPARK, such verifications can be conducted ahead of time.
This means that the runtime checks done by Ada can be safely disabled, eliminating a number of machine instructions and thus improving the performance of the system.
% TODO: mention something like how much of the codebase is covered by SPARK

We compare the performance of AdaFS with a C implementation of a FUSE-based MINIX 3 filesystem\footnote{\url{https://github.com/redcap97/fuse-mfs}}.
As AdaFS is not a complete filesystem, but only supports a small set of operations, it was not possible to use a standardised utility to test it.
Therefore, we created a microbenchmark in C that executes the relevant system calls and counts the number of CPU clock cycles necessary for each operation.
We compared some common filesystem operations, such as creating, writing, reading, and deleting files.
We used a virtual machine in VirtualBox 6.1.10 on a macOS host, running Debian 4.19.118, with FUSE version 3.4.1.
The disk images for the filesystem were stored on an SSD.

To calculate the number of CPU clock cycles an operation takes, we use a deterministic version of the ReaD Time Stamp Counter (RDTSC) instruction, RDTSCP, which is added as inline assembly in the C microbenchmark code.
Example code for this is shown in \autoref{code:rdtsc}.

\begin{lstlisting}[caption={Calculating clock cycles}, label={code:rdtsc}, language=C]
static __inline__ int64_t rdtsc_s(void) {
  unsigned a, d;
  asm volatile("cpuid" ::: "%rax", "%rbx", "%rcx", "%rdx");
  asm volatile("rdtsc" : "=a" (a), "=d" (d));
  return ((unsigned long)a) | (((unsigned long)d) << 32);
}

static __inline__ int64_t rdtsc_e(void) {
  unsigned a, d;
  asm volatile("rdtscp" : "=a" (a), "=d" (d));
  asm volatile("cpuid" ::: "%rax", "%rbx", "%rcx", "%rdx");
  return ((unsigned long)a) | (((unsigned long)d) << 32);
}
typedef int64_t cycle_t;

int main() {
  cycle_t cycles_before, cycles_after, cycles_per;
  cycles_before = rdtsc_s();
  // Call the test function here...
  cycles_after = rdtsc_e();
  cycles_per = cycles_after-cycles_before;
  printf("CPU cycles: %ld\n", cycles_per);
}
\end{lstlisting}

We choose RDTSCP instead of RDTSC because the CPU cannot reorder it relative to other instructions, as this reordering would cause noise in our results \cite{delorie2016}.
We set the \lstinline{isolcpus} kernel option at boot to isolate CPU 1, and then use the \lstinline{sched_affinity} function call to explicitly schedule each test on this CPU.
\autoref{code:schedule test} shows the code for this.

\begin{lstlisting}[caption={Schedule a test on CPU 1}, label={code:schedule test}, language=C]
#define _GNU_SOURCE
#include <sched.h>
void run_test(void) {
  // Schedule
  cpu_set_t the_cpu;
  int the_cpu_num = 1;
  CPU_ZERO(&the_cpu);
  CPU_SET(the_cpu_num, &the_cpu);
  if (sched_setaffinity(0, sizeof(the_cpu), &the_cpu) == -1) {
    perror("setaffinity failed");
  }

  // Run any tests below
  ...
}
\end{lstlisting}
We also assign interrupts to CPU 0 to avoid interference.
This ensures that no other processes are scheduled on the same CPU as our tests, i.e. that our results are as noiseless as possible.
We run FUSE in single-thread mode for both implementations of the filesystem.

We run the benchmark 30 times for each filesystem implementation; \autoref{tab:fs comparison} presents the median values for each implementation and operation.
% TODO: explain the plots and the tables

% comparing with this: https://github.com/redcap97/fuse-mfs
\begin{table}[h]
  \begin{subtable}[t]{\textwidth}
    \centering
    \begin{tabular}{l | r | r}
      Implementation & Create & Remove \\
      \hline \hline
      AdaFS & 528727341 & 550232 \\ % TODO: check this! this seems like waaaay too much of a difference...
      fuse-mfs & 3622328 & 525831
    \end{tabular}
    \caption{CPU cycles to create and remove files}
    \label{tab:create remove files}
  \end{subtable}

  \bigskip

  \begin{subtable}[t]{\textwidth}
    \centering
    \begin{tabular}{l | r | r | r | r}
      Implementation & Read 1 B & Read 1 KB & Read 10 KB & Read 100 KB \\
      \hline \hline
      AdaFS & 6710 & 2178 & 2183 & 2148 \\
      fuse-mfs & 6466 & 2149 & 2146 & 2153
    \end{tabular}
    \caption{CPU cycles to read files of varying sizes}
    \label{tab:read files}
  \end{subtable}

  \bigskip

  \begin{subtable}[t]{\textwidth}
    \centering
    \begin{tabular}{l | r | r | r | r}
      Implementation & Write 1 B & Write 1 KB & Write 10 KB & Write 100 KB \\
      \hline \hline
      AdaFS & 2238 & 2081 & 2084 & 2186 \\
      fuse-mfs & 2153 & 2060 & 2084 & 2124 \\
    \end{tabular}
    \caption{CPU cycles to write files of varying sizes}
    \label{tab:write files}
  \end{subtable}
  \caption{Comparing filesystem operation performance in C (fuse-mfs) and Ada (AdaFS).}
  \label{tab:fs comparison}
\end{table}

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.7]{read.png}
  \caption{Comparing file read performance in C (fuse-mfs) and Ada (AdaFS)}
  \label{fig:read comparison}
\end{figure}

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.7]{write.png}
  \caption{Comparing file write performance in C (fuse-mfs) and Ada (AdaFS)}
  \label{fig:write comparison}
\end{figure}
\clearpage
