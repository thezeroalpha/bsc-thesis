\section{Design \& implementation}
To explore ways of writing reliable code, a small, prototype filesystem (AdaFS) was implemented using the Ada 2012 programming language.
Some parts of this filesystem are written in the SPARK 2014 language, which is a subset of Ada that removes features not amenable to formal verification, and defines new aspects to support modular, constructive, formal verification \cite{sparkRM}.
The AdaCore GNAT Community 2020 package\footnote{\url{https://www.adacore.com/community}} is used, which provides, among others, the compiler and prover tools.
For testing purposes, a FUSE driver is written in C, and the built executables are linked with libfuse 3.9.2\footnote{\url{https://github.com/libfuse/libfuse}}.
The GNAT Project Manager is used to facilitate compilation of source files in different languages and linking of other required libraries.

\subsection{Filesystem design}
AdaFS is based on the MINIX 2 filesystem \cite{tanenbaum1997}, with some simplifications due to time constraints.
The MINIX operating system was written by Andrew Tanenbaum as an educational tool, and is compatible with UNIX, but has a more modular structure.
The MINIX filesystem was chosen as a model because it is not part of the operating system, but rather runs entirely as a user program.
As such, it is self-contained.
Furthermore, due to its educational purpose, it is thoroughly commented and easy to understand.
The second version of the file system was chosen because MINIX 3 is more complex, as it adds numerous improvements (e.g. for reliability) to place emphasis on its use in research and production \cite{minix3history}.

A disk is formatted as an AdaFS filesystem using the \textit{mkfs} executable.
The resulting disk layout is shown in \autoref{fig:adafs disk layout}.
The disk is divided into blocks of 1024 bytes, similarly to MINIX.
Blocks are collected in zones, which can be of size $2^n$ blocks.
This abstraction of blocks into zones can make it possible to allocate multiple blocks at once.

\begin{figure}[h]
  \centering
  \incfig{disk-layout}
  \caption{AdaFS disk layout. (\textit{n} = number of inode bitmap blocks, \textit{m} = number of zone bitmap blocks, \textit{i} = number of inode blocks, \textit{s} = number of blocks on disk)}
  \label{fig:adafs disk layout}
\end{figure}

The disk begins with a boot block that would optionally contain executable code.
Then, it contains a superblock, and two bitmaps.
The bitmaps are used for inode and zone allocation, and can potentially span multiple blocks.
Next, there are a few blocks containing space for inodes, potentially with more than one inode per block.
Finally, the rest of the blocks contain user data.

The superblock is the second block on the disk, and contains information about the layout of the filesystem.
In particular, it contains the number of inodes and zones on disk, the number of inode and zone bitmap blocks, the number of the first data zone, the base-2 logarithm of the number of blocks per zone, the maximum file size, and the magic number.
The magic number used to identify a correctly formatted disk is $\text{CACA}_{16}$; MINIX uses the magic number $2468_{16}$, but AdaFS avoids using the same number because a disk formatted by the AdaFS \textit{mkfs} utility is not necessarily equivalent to a disk formatted by the MINIX \textit{mkfs} utility.

The two bitmaps keep track of available inodes and zones, where the \textit{n}th bit of the inode or zone bitmap corresponds to the \textit{n}th inode or zone on disk, respectively.
If a bit in the inode bitmap is set to 1, that means the corresponding inode is allocated, and if it is set to 0, the inode is free.
This is the same for the zone bitmap, pertaining to zones.
One difference with MINIX is that, in MINIX, the first bit (bit zero) in the bitmaps must always be allocated, as the procedure that searches for a free inode or zone returns zero if no free inode/zone is found.
In Ada, indexing generally starts at 1, so all bits can be used -- as the first bit is bit one, this does not interfere with the allocation procedure.

The penultimate section of the disk contains inodes; the number of inodes is determined by the size of the disk.
The inodes have two representations: on-disk (\autoref{fig:inode on disk}) and in-memory (\autoref{fig:inode in memory}).
This allows the filesystem to make efficient use of disk space, while providing faster access to important values when the inode is loaded in memory.
There are 10 zones per inode: 7 direct zones (those that contain data), 1 single indirect zone (indicates a block that contains more direct zones), 1 double indirect zone (indicates a block that contains more single indirect zones), and 1 unused zone.
The unused zone is present for future use, potentially as a triple-indirect zone.

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.49\textwidth}
    \centering
    \resizebox{0.8\textwidth}{!}{\incfig{inode-on-disk}}
    \caption{On disk}
    \label{fig:inode on disk}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.49\textwidth}
    \centering
    \resizebox{0.7\textwidth}{!}{\incfig{inode-in-memory}}
    \caption{In memory}
    \label{fig:inode in memory}
  \end{subfigure}
  \hfill
  \caption{Inode representations}
  \label{fig:inode representations}
\end{figure}

The final section spans the rest of the blocks on the disk, broken into zones, and is available to store user data.
It can contain file data, or directory entries.

There are also some in-memory structures for working with open files.
The filesystem keeps a process table in memory, which is indexed by process ID (PID), and keeps track of inode information for all processes using the filesystem.
One entry corresponds to one process, and contains the inode numbers for the root and working directories of the process, as well as the list of open file descriptors.
Each open file descriptor corresponds to an entry in the filesystem's \textit{filp} table, which is shared among all processes and contains all the file position.
The rationale for a shared file position table comes from MINIX, and is based on problems with the semantics of the \textit{fork} system call \cite{tanenbaum1997}.
An entry in the filp table contains the number of file descriptors using that entry, the inode number, and the file position for the inode.
% TODO: maybe add here an example of inode lookup for the read() call

Due to time constraints, a number of simplifications were made compared to MINIX.
In particular, only the features necessary for basic functionality of the system were implemented.
The filesystem does not cache any information, and there is no in-memory inode table; all data is written directly to disk.
Furthermore, the current implementation does not keep track of file mode, owner, group, or timestamps.
This results in a limited filesystem, which nonetheless completes its function as a proof-of-concept.

\subsection{Language features \& implementation specifics}
\paragraph{Strong typing}
Ada is a strongly typed language, which helps the programmer distinguish between types that are logically different, even if their underlying representation is the same.
Furthermore, the compiler will automatically catch any bugs that would be caused by assigning a value of an incorrect type to a variable.
In order for a value to be assigned to a variable, two constraints must be satisfied: the value and variable must have the same type, and the value must satisfy all constraints on the variable (such as the range for an integral data type) \cite{barnes2014}.
Conversion between types is allowed, but only if it is explicit, and if the target type is an ancestor of the current type (for example, a positive integer may be converted to an integer, but not vice-versa).
An example of the use of types is the definition of a character buffer of arbitrary size, followed by the definitions of different block types including a constrained version of the buffer type, shown in \autoref{code:block type definitions}.

\begin{lstlisting}[caption={Block type definitions}, label={code:block type definitions}, language=Ada]
type data_buf_t is array (Positive range <>) of Character;

type inode_block_t is array (1..block_size/on_disk'Size) of on_disk;
type zone_block_t is array (1..n_indirects_in_block) of Natural;
type dir_entry_block_t is array (1..block_size/direct'Size) of direct;
subtype data_block_t is data_buf_t (1..data_block_range'Last);
\end{lstlisting}

\paragraph{Controlled types}
Controlled types allow the programmer to specify precisely what happens when a variable of a given type is declared, or when it goes out of scope.
They are not permitted in SPARK, because the compiler inserts implicit calls to allow this functionality \cite{sparkRM}.
The initialization and destruction of variables of a controlled type is handled with custom \lstinline[language=Ada]{initialize} and \lstinline[language=Ada]{finalize} procedures for the type, thus the compiler needs to ensure these procedures are called in execution.
However, in AdaFS, controlled types are not used for any filesystem logic, and are only used with disk I/O to make sure that e.g. the variable containing the superblock is initialized properly with the type of I/O the filesystem uses.
Therefore, this was deemed acceptable for this prototype.

\paragraph{Lack of pointers}
The C codebase of MINIX makes extensive use of pointers to refer to inodes and other structures in memory, addresses on disk, etc.
Ada has access types, which are similar to pointers in some ways, but due to the complexity of verifying a program's behavior when it contains pointers, SPARK severely restricts the possibilities of using access types \cite{sparkRM}.
Thus, alternative methods must be used to provide similar functionality.

One way to solve this is with parameter modes.
Ada allows specifying the mode of each parameter in a procedure, which designates how the parameter will be used in execution.
If a parameter is of `in' mode, it is only read in the procedure, and is not modified -- this is the default mode.
If a parameter is of `out' mode, the value of the parameter before the call is irrelevant, as it will receive a value in the procedure.
Finally, if a parameter is of `in out' mode, it is both read and updated in the procedure.
This third mode provides functionality similar to a pointer.

However, SPARK requires that functions be purely functional; that is, they cannot have side effects, such as parameters with a mode of `out' or `in out'.
Here, two solutions are possible.
In some cases, it may be preferred to add the return value as an `out' parameter, and rewrite the function as a procedure.
In other cases, it is better for the function to return multiple values, which is possible with a record type.
An example is the function \lstinline[language=Ada]{parse_next} in \autoref{code:function returning record}, which returns two values, wrapped in the record type \lstinline[language=Ada]{parsed_res_t}.

\begin{lstlisting}[caption={Parse function returning the parsed component and the new cursor position (ellipses denote code omitted for brevity)}, label={code:function returning record}, language=Ada]
subtype cursor_t is Natural range path'Range;

type parsed_res_t is record
  next : adafs.name_t;
  new_cursor : cursor_t;
end record;

function parse_next
  (path : adafs.path_t; cursor : cursor_t) return parsed_res_t
is
  ...
end parse_next;
\end{lstlisting}

\paragraph{Modularisation}
Ada supports modularisation in the form of packages, and forms a single translation unit, which can contain member entities such as subprograms, variables, and types.
Information hiding is done by defining members as private.
A package is separated into two parts, which are placed in separate files: the \textit{specification} (the public interface for the package), and the \textit{body} (the implementation).
The compiler always checks whether the package body matches the specification, and refuses to compile the code if this is not the case.
\autoref{code:inode specification and body} shows an excerpt of the specification and body of the \lstinline[language=Ada]{adafs.inode} package.

A package can also have child packages: for example, the \lstinline[language=Ada]{adafs.inode} package is a child of the \lstinline[language=Ada]{adafs} package.
A child package has access to all member entities defined in the specification of its parent(s), including private members.

\begin{lstlisting}[caption={Excerpt from the adafs.inode package specification and body (ellipses denote code omitted for brevity)}, label={code:inode specification and body}, language=Ada]
-- adafs-inode.ads
package adafs.inode
  with SPARK_Mode
is
  ...
  function calc_num_inodes_for_blocks (nblocks : Natural) return Natural
    with ...;
end package adafs.inode

-- adafs-inode.adb
package body adafs.inode
  with SPARK_Mode
is
  function calc_num_inodes_for_blocks
    (nblocks : Natural) return Natural
  is
    inode_max : constant := 65535;
    i : Natural := nblocks/3;
  begin
    ...
    return i;
  end calc_num_inodes_for_blocks;
end adafs.inode;
\end{lstlisting}

It is also possible to create \textit{generics}.
Generics are somewhat similar to objects in the OOP paradigm, in that they can be instantiated with parameters.
However, an important difference is that instantiation can only occur in a declarative region.
Both subprograms and packages can be generic.
For example, \autoref{code:generic reading function} shows a generic function for reading data from a disk, and its instantiation.
As Ada's \lstinline[language=Ada]{Stream_IO} requires specifying the type to be read, using a generic function helps with code reuse, with \lstinline[language=Ada]{elem_t} designating the type to be read, which is passed in at instantiation.
The downside of generics is that they cannot be analyzed directly by SPARK, but must instead be verified from the context of instantiation (i.e., SPARK mode must be enabled in the package or subprogram that instantiates the generic) \cite{sparkRM}.

\begin{lstlisting}[caption={Generic function for reading a block of type \textnormal{elem\_t}}, label={code:generic reading function}, language=Ada]
-- disk.ads
generic
  type elem_t is private;
function read_block (num : block_num) return elem_t;

-- disk.adb
function read_block (num : block_num) return elem_t is
  result : elem_t;
begin
  if not is_reading then
    sio.set_mode(stream_io_disk_ft, sio.in_file);
  end if;
  go_block (num);
  elem_t'read (stream_io_disk_acc, result);
  return result;
end read_block;
\end{lstlisting}

\paragraph{Interfacing with other languages}
Ada has a mechanism to allow interfacing with other programming languages, such as Fortran, COBOL, or C.
This is done by replicating the types and subprogram signatures in Ada.
The Interfaces library package\footnote{\url{https://www.adaic.org/resources/add_content/standards/05aarm/html/AA-B-2.html}} provides types and subprograms for this purpose.
For example, for C, there are the Interfaces.C\footnote{\url{http://www.ada-auth.org/standards/12rm/html/RM-B-3.html}} and Interfaces.C.Strings\footnote{\url{http://www.ada-auth.org/standards/12rm/html/RM-B-3-1.html}} packages, which provide the types \lstinline[language=Ada]{chars_ptr} (mirroring \lstinline[language=C]{char*} in C), \lstinline[language=Ada]{int} (mirroring \lstinline[language=C]{int} in C), etc.
This allows \textit{exporting} subprograms from Ada, and calling them from a C program.
\autoref{code:interfacing c and ada} shows a specification of a subprogram that is exported to C by specifying the \lstinline[language=Ada]{Export} and \lstinline[language=Ada]{Convention} aspects (as well as an external name to use when calling the subprogram from C).
The subprogram is then declared as \lstinline[language=C]{extern} in C, and called from the C program's main function.
Since the main program is written in a language different from Ada, the initialization and finalization procedures (\lstinline[language=C]{adainit(void)} and \lstinline[language=C]{adafinal(void)}) must also be declared and called before and after any other Ada subprograms, respectively.
The GNAT Project Manager handles compiling and linking of files written in different languages.
Unfortunately, interfacing code is not amenable to formal verification.

\begin{lstlisting}[caption={Interfacing code written in C and Ada. \textnormal{declarations.adb} is omitted for brevity, but is assumed to contain an implementation of the factorial function conforming to the specification.}, label={code:interfacing c and ada}, language=Ada, alsolanguage=C]
-- declarations.ads
with Interfaces.C;
package Declarations is
  function Factorial  (n : Interfaces.C.int) return Interfaces.C.int
    with Export => True,
         Convention => C,
         External_Name => "ada_factorial";
end Declarations;

-- main.c
#include <stdio.h>
extern void adainit (void);
extern void adafinal (void);
extern int ada_factorial(int n);

int main(int argc, const char *argv[]) {
  adainit();
  int n = 5;
  printf("%d\n", ada_factorial(n)); // 120
  adafinal();
}
\end{lstlisting}

\paragraph{FUSE \& the FUSE driver}
% FIXME: some of this should be in background info
FUSE is a software interface that allows running filesystem code in userspace, with FUSE bridging the gap between the filesystem and the kernel.
This simplifies the development of filesystems, because access to the kernel and modification of kernel code is not necessary.
FUSE allows a filesystem to be developed iteratively; i.e., first it can be implemented and tested with FUSE, and later connected to a kernel if needed.

To implement a filesystem with FUSE, the code needs to be linked with the FUSE library (libfuse), and a driver must be written to specify the filesystem's handler functions for various operations.
As FUSE is written in C, the driver for AdaFS is currently also written in C, with a wrapper in Ada to convert values between C types and Ada types.
FUSE specifies a \lstinline[language=C]{struct} with pointers to functions that should be written by the programmer for the specific filesystem they are implemented.
The library also provides, among others, a function to fill file entries into a buffer, a \lstinline[language=C]{struct} to store open file information, and a function to get the context of the current operation (such as the PID requesting the operation).
\autoref{code:fuse open} shows an example from the driver, with an implementation of the open file operation.

\begin{lstlisting}[caption={FUSE driver implementation of \textnormal{open}}, label={code:fuse open}, language=C]
#define FUSE_USE_VERSION 31
#include <fuse.h>
// Declare the external filesystem open function written in Ada
extern int ada_open(const char *path, pid_t pid);

// The driver's open function
int adafs_open(const char *path, struct fuse_file_info *finfo) {
  pid_t pid = fuse_get_context()->pid;
  int fd = ada_open(path, pid);
  finfo->fh = fd;
  return 0;
}

// Register the function with FUSE
static struct fuse_operations adafs_ops = {
  .open = adafs_open
};

int main(int argc, char **argv) {
  ...
  return fuse_main(argc, argv, &adafs_ops, NULL);
}
\end{lstlisting}

\paragraph{Formal verification}
Unfortunately, much of the code in its current form is not amenable to formal verification.
These are namely the parts involving file input and output, and functions that work with C types (i.e. the FUSE driver).
To mitigate this, we attempted to make use of an existing project containing FUSE bindings for Ada\footnote{\url{https://github.com/medsec/ada-fuse}}, but as the project has not been maintained since 2016, we were unable to compile it.

Nevertheless, large parts of filesystem logic are formally verifiable.
Therefore, the code base was split into two distinct packages: the \textit{adafs} package, which contains filesystem logic that is strictly in the SPARK language, and the \textit{disk} package, which contains unverifiable elements such as disk I/O.
The \textit{adafs} package does not include any specifics about the type of disk being used, as the \textit{disk} interface hides implementation details.
Thus, when needed, and when an alternative is found, the \textit{disk} package can simply be replaced with a verifiable implementation that exposes an identical interface.

For the parts that are formally verifiable, two types of contracts are available: functional and data contracts.
Functional contracts describe how a subprogram should function; that is, the pre- and post-conditions for a given subprogram.
They are written as boolean predicate logic expressions.
Pre-conditions are evaluated before entry into the subprogram, and post-conditions are evaluated after exit from the subprogram (and can therefore mention the subprogram's result).
SPARK can check these conditions at each call site to ensure that no subprogram call violates the conditions, and that the output(s) are shown to be conformant with the specification (the returned result for a function, and the \lstinline[language=Ada]{out} or \lstinline[language=Ada]{in out} parameters for a procedure).

The second type of contract available are data contracts.
SPARK conducts flow analysis, which models the flow of information during a subprogram's execution.
It checks for uninitialized variables, ineffective statements, and incorrect parameter modes.
It is possible to specify which global variables are read, written, or both read and written in the subprogram, using the \lstinline[language=Ada]{Global} aspect.
If no global variables are used, the value of the aspect is set to \lstinline[language=Ada]{null}.
It is also possible to specify data dependencies between a subprogram's inputs and outputs.

For example, \autoref{code:formal verification example} shows a function to get an entry from the process table, which specifies the functional and data contracts to be fulfilled for the function.
The \lstinline[language=Ada]{Global} aspect specifies that the function only depends on the value of the package variable \lstinline[language=Ada]{tab} for input.
The \lstinline[language=Ada]{Depends} aspect states that the result of the function only depends on the \lstinline[language=Ada]{tab} and \lstinline[language=Ada]{pid} variables (that is, the variable stated in the \lstinline[language=Ada]{Global} aspect, and the parameter of the function).
The post-condition states that the \lstinline[language=Ada]{is_null} component of the returned variant record will be set to True if there is no entry in \lstinline[language=Ada]{tab} for the provided PID; otherwise, the inode number of the PIDs working directory will be non-zero.
With the SPARK toolchain, we can verify that these constraints are all satisfied.

\begin{lstlisting}[caption={Functional and data contracts}, label={code:formal verification example}, language=Ada]
function get_entry (pid : tab_range) return entry_t with
  Global => (input => tab),
  Depends => (get_entry'Result => (tab, pid)),
  Post => (if tab(pid).is_null
           then get_entry'Result.is_null
           else get_entry'Result.workdir > 0);
\end{lstlisting}

