\section{Introduction}
As K. J. Parker said, ``the fastest, cheapest and easiest way to build something is properly the first time'' \cite{parker2007}.
Software bugs can cost companies customers, reputation, and up to millions of dollars.
If these bugs are in the filesystem, they can destroy potentially irreplaceable and priceless data.
Unfortunately, given that large filesystem projects contain millions of lines of code, bugs are inevitable.
In 2017, a bug in the NT File System used by Windows was found, which allowed anyone to crash Windows 7 or 8.1 \cite{bright2017}.
Just this year, a bug in the Apple File System could prevent users from making a bootable clone of their disk \cite{bombich2020}.
There are currently 112 bugs reported in the Bugzilla database for the Ext4 filesystem, and 611 bugs reported for the Btrfs filesystem \cite{bugzilla2020}.

It is safe to say that we need a way to build more reliable software, without spending time and money fixing issues that could have been prevented from the start.
C is in widespread use in the development of operating systems and their components, including the Ext4 filesystem.
However, C is an inherently unsafe language, and its permissiveness means that errors are relatively easy to make.
Attacks exploiting these errors can be devastating, such as the 2001 CodeRed worm that infiltrated enterprise networks \cite{trendmicro2002}.

There have been efforts in the past to improve the reliability of systems, with the largest amount focusing on operating systems and their kernels.
There has also been some research in the area of filesystem reliability, and some projects have tried to develop frameworks for building reliable filesystems.
However, many of the frameworks require learning a language or programming style that is not very familiar to people who are used to working with C-style programming languages; moreover, some approaches may require radically changing the logic of the filesystem.

This paper explores an alternative way to write reliable software, particularly in the context of filesystems.
We use the Ada programming language and its SPARK subset, which were created specifically for the purpose of building high-reliability software.
We develop a small filesystem based on that of MINIX 2, demonstrating that using Ada could be a suitable approach for writing low-level filesystem code.
We conduct formal verification of some of the parts of the filesystem, and analyze and evaluate its effectiveness.

In short, this paper's main contributions are:

\begin{itemize}
  \item a novel approach to writing filesystems, using Ada, a statically-typed imperative language that is more similar to the traditional choice of C,
  \item formal verification of some parts of the filesystem, which are written in the SPARK subset of Ada and verified using predicate logic assertions, proving automatically that the code is free of errors,
  \item an evaluation of the performance effects of using Ada and conducting formal verification, compared to a C implementation.
\end{itemize}
